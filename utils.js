const crypto = require('crypto');
const fs = require('fs');

// ===========================================================================
// ............... 1. pre-encryption built on aes-128-ecb ...............
// ===========================================================================
let password = "userChosenPassword"; // later let user choose password
const file = 'sample.txt'; 		    // later let user choose file

/*
 * Use userChosenPassword and a random salt to derive a key, use the key to construct a pre-encryption cipher,
 * built on aes-128-ecb.
 * @return: an obj of two functions and a key:
 *          function encrypt: take the data buffer to encrypt and return the encrypted
 *          function decrypt: take the data buffer to decrypt and return the decrypted
 *          key: a computational-expensive derived key
 */
const createPreEncryption = (userChosenPassword) => {
    const algo = 'aes-128-ecb';  // key: 128 bits; block: 128 bits;
    const salt = crypto.randomBytes(20);
    const key = crypto.scryptSync(userChosenPassword, salt, 16);

    const encrypt = (dataBuf) => {
            const cipher = crypto.createCipheriv(algo, key, '');  // ecb mode doesn't have an iv
            const encrypted = cipher.update(dataBuf);
            const Xi_stream = Buffer.concat([encrypted, cipher.final()]);
            // split stream into an arr of small buffers of 16 bytes each
            let start = 0;
            let Xi = [];
            while (start + 16 <= Xi_stream.length) {
                Xi.push(Xi_stream.slice(start, start + 16));
                start += 16;
            }
            return {Xi_stream, Xi};
    };

    const decrypt = (dataBuf) => {
            const decipher = crypto.createDecipheriv(algo, key, '');
            const decrypted = decipher.update(dataBuf);
            const result = Buffer.concat([decrypted, decipher.final()]);
            return result;
    };
    // return an obj of two functions and the derived key
    return({encrypt, decrypt, key});
};

// @isFilePath: is true if `data` is a path to a file; is false if `data` is a data Buffer
const encDec = (data, cryptoAlgo, isFilePath=true) => {
    if (!isFilePath) {
        console.log(`to encrypt: ${data}`);
        let encrypted = cryptoAlgo.encrypt(data);
        console.log(`encrypted: \n${encrypted.toString('hex')}`);

        const decrypted = cryptoAlgo.decrypt(encrypted);
        console.log(`decrypted: \n${decrypted.toString('utf-8')}`);

        return ;
    }

    return new Promise((resolve, reject) => {
        fs.readFile(data, (err, data) => {
            if (err) reject(`Error in encDecFile: ${err}`);

            const encrypted = cryptoAlgo.encrypt(data);
            console.log(`encrypted: \n${encrypted.toString('hex')}`);
            console.log(`encrypted length: \n${encrypted.length} bytes`);

            const decrypted = cryptoAlgo.decrypt(encrypted);
            console.log(`decrypted: \n${decrypted.toString('utf-8')}`);
        });
    });
};

// // sample usage
// let E;
// createPreEncryption(password)
//     .then((res) => {
//         E = res;	// store it in a global variable
//         console.log(`inside then: ${res}`);
//         console.log(`derived key: ${res.key.toString('hex')}`);
//         encDec(file, res);	 // chaining Promise obj
//     })
//     .catch((err) => console.log(err));


// ===========================================================
// ............... 2. PRNG build on aes-128-ctr...............
// ===========================================================

// the file is encrypted, block size is S-bit,
// S must be a multiple of 128 because block size is 128,
// need PRG to generate S/128*64 = S/2 bits
// where num of blocks is the same as the encrypted file, but each block only has 64 bits

/*
 * Use userChosenPassword and a random salt to derive a key, use the key to construct a pseudorandom generator,
 * built on aes-128-ctr.
 * @return: an obj of one function and a key:
 *          function gen: take the #bytes to generate and return the generated bytes in a buffer
 *          key: a computational-expensive derived key
 */
const createPRNG = (userChosenPassword) => {
    const algo = 'aes-128-ctr';   // key: 128 bits; block: 128 bits;
    const salt = crypto.randomBytes(20);
    const key = crypto.scryptSync(userChosenPassword, salt, 16);
    // prepare iv
    const iv = crypto.randomBytes(16);

    // numBytes = (number of Bytes in file-to-encrypt) / 2
    const gen = (numBytes) => {
        const dataBuf = Buffer.alloc(numBytes, 0);
        const cipher = crypto.createCipheriv(algo, key, iv);
        const encrypted = cipher.update(dataBuf);
        const result = Buffer.concat([encrypted, cipher.final()]);
        // split result into an arr of small buffers of 8 bytes each
        let start = 0;
        let smallBufs = [];
        while (start + 8 <= result.length) {
            smallBufs.push(result.slice(start, start + 8));
            start += 8;
        }
        return smallBufs;
    };

    // an obj of gen function and the derived key
    return({gen, key});
}

// // sample usage
// let G;
//
// createPRNG(password)
//     .then((res) => {
//         G = res;	// store it in a global variable
//         // encDec(file, res);	 // chaining Promise obj
//         const encrypted = res.gen(10);
//         console.log(`derived key: ${res.key.toString('hex')}`);
//         console.log(`encrypted: \n${encrypted.toString('hex')}`);
//         console.log(`encrypted length: \n${encrypted.length} bytes`);
//     })
//     .catch((err) => console.log(err));


// =========================================================
// ............... 3. two PRFs built on bf-cbc..............
// =========================================================

// bf-cbc: blow fish algorithm on cbc mode
// block size is 64 bits, key size can be 32~448 bits, here we choose key size 64 bits.

// ............... 3.1 smallF ...............
/*
 * Use userChosenPassword and a random salt to derive a key, use the key to construct a pseudorandom function.
 * @return: an obj of two functions and a key:
 *          function encrypt: take the data buffer to encrypt and return the encrypted
 *          function decrypt: take the data buffer to decrypt and return the decrypted
 *          key: a computational-expensive derived key
 */
const createSmallF = (userChosenPassword) => {
    const algo = 'bf-cbc';  // key: 64 bits; block: 64 bits;
    const salt = crypto.randomBytes(20);
    const key = crypto.scryptSync(userChosenPassword, salt, 8);
    const iv = crypto.randomBytes(8);

    const encrypt = (dataBuf) => {
        const cipher = crypto.createCipheriv(algo, key, iv);
        // disable padding, because we make sure to feed it the correct length (64 bits)
        cipher.setAutoPadding(false);
        const encrypted = cipher.update(dataBuf);
        const result = Buffer.concat([encrypted, cipher.final()]);
        return result;
    };

    const decrypt = (dataBuf) => {
        const decipher = crypto.createDecipheriv(algo, key, iv);
        // disable padding, because we make sure to feed it the correct length (64 bits)
        decipher.setAutoPadding(false);
        const decrypted = decipher.update(dataBuf);
        const result = Buffer.concat([decrypted, decipher.final()]);
        return result;
    };
    // return an obj of two functions and the derived key
    return({encrypt, decrypt, key});
};


// // sample usage
// let f;
// createSmallF(password)
//     .then((res) => {
//         f = res;	// store it in a global variable
//         console.log(`inside then: ${res}`);
//         console.log(`derived key: ${res.key.toString('hex')}`);
//         encDec(file, res);	 // chaining Promise obj
//     })
//     .catch((err) => console.log(err));

// ............... 3.2 bigF ...............
/* unlike the previous functions,
 * big F don't need to go through the computational-costly key derivation process
 * instead, each time F is used, a computed key is passed to createBigG function.
 * The returned object has an encrypt method that does encryption.
 * (This is to make the interface across the primitives as similar as possible.)
 * @return: an obj of one function:
 *          function encrypt: take the data buffer to encrypt and return the encrypted
 */
const createBigF = (iv) => {  // remember to pass it a 64bit iv
    const algo = 'bf-cbc';  // key: 64 bits; block: 64 bits;

    const encrypt = (computedKey, dataBuf) => {
        const cipher = crypto.createCipheriv(algo, computedKey, iv);
        cipher.setAutoPadding(false);  // disable padding, because we make sure to feed it the correct length
        const encrypted = cipher.update(dataBuf);
        const result = Buffer.concat([encrypted, cipher.final()]);
        return result;
    }
    // return an obj of one function
    return {encrypt};
}


// // sample usage
// let F = createBigF('aaaaaaaa');
// fs.readFile(file, (err, data) => {
//     if (err) throw err;
//
//     const encrypted = F.encrypt(data);
//     console.log(`encrypted: \n${encrypted.toString('hex')}`);
//     console.log(`encrypted length: \n${encrypted.length} bytes`);
// });


module.exports = {createPreEncryption, createPRNG, createSmallF, createBigF, encDec};